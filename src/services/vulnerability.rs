use super::{Notification, NotificationService};
use crate::{config::ServiceConfig, state::Manager, telegram};
use async_trait::async_trait;
use serde::Deserialize;
use std::time::Duration;
use tracing::{info, warn};

pub struct Service {
    state: Manager,
    config: ServiceConfig,
    client: reqwest::Client,
}

impl Service {
    pub fn new(config: ServiceConfig, client: reqwest::Client) -> Self {
        Self {
            state: Manager::new("seen_vulnerabilities.json", Duration::from_secs(30 * 24 * 3600)),
            config,
            client,
        }
    }
}

#[derive(Debug)]
pub struct VulnerabilityNotification {
    id: String,
    severity: String,
    score: f64,
    description: String,
    url: String,
    time: i64,
}

impl Notification for VulnerabilityNotification {
    fn get_unique_id(&self) -> &str { &self.id }
    fn get_timestamp(&self) -> i64 { self.time }
    fn format_message(&self) -> String {
        let title = "ðŸš¨ *Critical Vulnerability Alert* ðŸš¨";
        let time_str = chrono::DateTime::from_timestamp(self.time, 0)
            .map(|t| t.format("%c").to_string())
            .unwrap_or_else(|| "N/A".to_string());
        
        let score_str = telegram::escape_markdown(&format!("{:.1}", self.score));

        let description_block = if !self.description.is_empty() {
            format!("*Description:*\n```\n{}\n```\n", self.description)
        } else {
            "".to_string()
        };

        format!(
            "{}\n\n*CVE ID:* {}\n*Severity:* {} \\(Score: {}\\)\n*Published:* {}\n{}{}\n*Details:* [NVD Details]({})",
            title,
            telegram::escape_markdown(&self.id),
            telegram::escape_markdown(&self.severity),
            score_str,
            telegram::escape_markdown(&time_str),
            description_block,
            if !description_block.is_empty() { "" } else { "\n" }, // Add newline if no description
            self.url
        )
    }
}

#[async_trait]
impl NotificationService for Service {
    fn name(&self) -> &str { "Vulnerability" }
    fn get_config(&self) -> &ServiceConfig { &self.config }
    fn get_state_manager(&self) -> &Manager { &self.state }

    async fn check_for_notifications(&self) -> anyhow::Result<Vec<Box<dyn Notification>>> {
        #[derive(Deserialize, Debug)]
        struct CveItem {
            cve: Cve,
        }

        #[derive(Deserialize, Debug)]
        struct Cve {
            id: String,
            published: String,
            descriptions: Vec<Description>,
            metrics: Metrics,
        }

        #[derive(Deserialize, Debug)]
        struct Description {
            lang: String,
            value: String,
        }
        
        #[derive(Deserialize, Debug)]
        struct Metrics {
            #[serde(rename = "cvssMetricV31", default)]
            cvss_metric_v31: Vec<CvssMetricV31>,
        }

        #[derive(Deserialize, Debug)]
        struct CvssMetricV31 {
            #[serde(rename = "cvssData")]
            cvss_data: CvssData,
        }

        #[derive(Deserialize, Debug)]
        struct CvssData {
            #[serde(rename = "baseScore")]
            base_score: f64,
            #[serde(rename = "baseSeverity")]
            base_severity: String,
        }

        #[derive(Deserialize, Debug)]
        struct NvdResponse {
            vulnerabilities: Vec<CveItem>,
        }

        let severities_to_fetch = ["CRITICAL"];
        let mut all_notifications: Vec<Box<dyn Notification>> = Vec::new();

        for severity in severities_to_fetch {
            info!(severity, "Checking for vulnerabilities...");

            let pub_end_date = chrono::Utc::now();
            let pub_start_date = pub_end_date - chrono::Duration::hours(1);

            let url = format!(
                "https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate={}&pubEndDate={}&cvssV3Severity={}",
                pub_start_date.to_rfc3339_opts(chrono::SecondsFormat::Millis, true),
                pub_end_date.to_rfc3339_opts(chrono::SecondsFormat::Millis, true),
                severity
            );

            let res = self.client.get(&url).send().await?;
            if !res.status().is_success() {
                warn!(status = %res.status(), "NVD API returned non-200 status for severity {}", severity);
                continue;
            }

            let data: NvdResponse = res.json().await?;

            for item in data.vulnerabilities {
                let cve = item.cve;
                if !self.state.is_seen(&cve.id).await {
                    let pub_time = match chrono::DateTime::parse_from_rfc3339(&cve.published) {
                        Ok(t) => t,
                        Err(_) => continue,
                    };
                    
                    if let Some(metric) = cve.metrics.cvss_metric_v31.first() {
                        let desc = cve.descriptions.iter().find(|d| d.lang == "en").map_or("", |d| &d.value);
                        
                        let notif = Box::new(VulnerabilityNotification {
                            id: cve.id.clone(),
                            severity: metric.cvss_data.base_severity.clone(),
                            score: metric.cvss_data.base_score,
                            description: desc.to_string(),
                            url: format!("https://nvd.nist.gov/vuln/detail/{}", cve.id),
                            time: pub_time.timestamp(),
                        });

                        all_notifications.push(notif);
                        self.state.add(cve.id, pub_time.timestamp()).await;
                    }
                }
            }
            tokio::time::sleep(Duration::from_secs(6)).await;
        }

        Ok(all_notifications)
    }
}